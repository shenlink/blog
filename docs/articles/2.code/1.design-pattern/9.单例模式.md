---
outline: deep
title: 单例模式
url: 9
createtime: 2024-11-12 12:46:31
updatetime: 2025-06-16 04:53:11
---

# 单例模式

## 1. 引言

单例模式作为一种经典的创建型设计模式，旨在确保某个类只有一个实例，并且能够提供全局的访问点。它解决了实例化过多、资源浪费以及访问冲突等问题，成为在多个领域中广泛使用的设计模式。本文将深入探讨单例模式的定义、应用场景及其优缺点。

## 2. 起源与背景

单例模式作为一种设计模式，最早由《设计模式：可复用面向对象软件的基础》一书中的四位作者——Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 提出。尽管单例模式的概念在书中并没有作为单独一章讨论，但它属于“创建型模式”中的重要一员。随着面向对象思想的普及，单例模式在解决对象实例化过程中的资源浪费、同步问题等方面，逐渐得到了广泛应用。今天，单例模式已经成为很多系统架构中不可或缺的组成部分，尤其是在涉及资源共享的场景中，如数据库连接池、配置管理和日志系统等。

## 3. 定义与分类

**单例模式**（Singleton Pattern）是一种创建型设计模式，旨在保证一个类只有一个实例，并提供全局访问点。它确保类的实例在整个应用程序中始终保持唯一，且可以被任何地方访问。单例模式通常用于需要共享资源、控制并发访问、或防止多次实例化的场景。

单例模式通常具有以下特点：

- **唯一性**：类只能有一个实例。即使在多个线程或进程中，它也不会创建多个实例。
- **全局访问点**：提供全局访问点，允许任何地方访问该唯一实例。通常通过静态方法（如`getInstance()`）来获取该实例。
- **延迟实例化**：实例的创建通常是懒加载的，只有在第一次使用时才会创建，这有助于节省资源。

## 4. 模式的应用场景

单例模式属于创建型设计模式，它的主要目的是保证某个类只有一个实例，并提供全局访问点。在以下场景中，单例模式具有特别的优势：

- **数据库连接池**：确保数据库连接池在整个应用中只有一个实例，避免了每次请求都创建连接的资源浪费。
- **配置管理类**：通常应用程序的配置文件只需要一个统一的管理入口，单例模式能够确保配置类只有一个实例并且全局共享。
- **日志管理类**：日志类通常需要单一实例来处理不同模块的日志，避免日志实例的重复创建。

在这些场景中，单例模式的使用能够大大减少系统资源的消耗，并简化代码结构。

## 5. 优缺点分析

单例模式具有以下优点：

- **控制实例的数量**：保证类只有一个实例，避免了内存浪费和数据不一致的问题。
- **全局访问点**：通过静态方法或变量，使得类的实例能够在全局范围内被访问，简化了系统设计。
- **延迟实例化**：可以根据需要延迟创建实例，提高系统性能。

然而，单例模式也存在一些缺点：

- **全局状态**：单例模式实现了全局状态，这可能会使得类的行为不容易追踪，导致代码的可维护性下降。
- **过度设计**：有时开发者为了实现单例模式而增加不必要的复杂度，可能导致系统过于复杂。
- **并发问题**：在多线程环境下，单例模式的实现需要特别小心，防止多个线程同时创建实例。

## 6. 实现

### java实现

#### 1. 饿汉式(静态常量)

```java
// 饿汉式(静态变量)
class Singleton {
    // 构造方法私有化，不能在外部实例化
    private Singleton() {
    }

    // 创建实例对象
    private final static Singleton instance = new Singleton();

    // 返回实例对象
    public static Singleton getInstance() {
        return instance;
    }
}
``` 

优点：在类加载的时候就完成了实例化，避免了线程同步问题

缺点：没有实现懒加载


#### 2. 饿汉式(静态代码块)

```java
// 饿汉式(静态代码块)
class Singleton {
    // 构造方法私有化，不能在外部实例化
    private Singleton() {
    }

    private static Singleton instance;

    // 创建实例对象
    static {
        instance = new Singleton();
    }

    // 返回实例对象
    public static Singleton getInstance() {
        return instance;
    }
}
```

优点：静态代码块里面的代码在类加载时就会执行，此时已经完成了实例化，避免了线程同步问题

缺点：没有实现懒加载


#### 3. 懒汉式(线程不安全)

```java
// 懒汉式(线程不安全)
class Singleton {
    private static Singleton instance;

    private Singleton() {
    }

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

优点：实现了懒加载

缺点：线程不安全。单线程的情况下可以使用


#### 4. 懒汉式(同步方法)

```java
// 懒汉式(同步方法)
class Singleton {
	private static Singleton instance;

	private Singleton() {
	}

	public static synchronized Singleton getInstance() {
		if (instance == null) {
			instance = new Singleton();
		}
		return instance;
	}
}
```

优点：解决了线程不安全问题

缺点：效率低，synchronized锁住了整个方法，每次访问该方法，都会锁住整个方法，但是，instance实例在第一次访问的时候就已经实例化，后续只需要直接返回，没有线程安全的问题，也就不需要每次都锁住整个方法，导致方法的效率降低


#### 5. 懒汉式(同步代码块)

```java
// 懒汉式(同步代码块)
class Singleton {
    private static Singleton instance;

    private Singleton() {
    }

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                instance = new Singleton();
            }
        }
        return instance;
    }
}
```

优点：相比懒汉式(同步方法)，效率有了一定的提高

缺点：线程不安全


#### 6. 双重检查

```java
// 双重检查
class Singleton {
	private static volatile Singleton instance;

	private Singleton() {
	}

	public static Singleton getInstance() {
		if (instance == null) {
			synchronized (Singleton.class) {
				if (instance == null) {
					instance = new Singleton();
				}
			}
		}
		return instance;
	}
}
```

优点：加入双重检查代码，解决线程安全问题, 同时解决懒加载问题，同时解决了效率问题


#### 7. 静态内部类

```java
// 静态内部类
class Singleton {
	private Singleton() {
	}

	private static class SingletonInstance {
		private static final Singleton INSTANCE = new Singleton();
	}

	public static synchronized Singleton getInstance() {

		return SingletonInstance.INSTANCE;
	}
}
```

优点：通过类加载机制解决了线程安全问题，在Singleton类被装载时并不会立即实例化，而是在需要实例化，实现了懒加载的效果


#### 8. 枚举

```java
// 枚举
enum Singleton {
	INSTANCE;

	public static Singleton getInstance() {
		return INSTANCE;
	}
}
```

优点：避免了线程安全问题，还能防止反序列化重新创建新的对象


### php实现
```php
<?php

declare(strict_types=1);

use RuntimeException;

// 单例类
class Singleton
{
    // 实例
    private static $instance;

    // 禁止new初始化
    private function __construct()
    {
    }

    // 获取实例
    public static function getInstance(): self
    {
        if (null === self::$instance) {
            self::$instance = new self();
        }

        return self::$instance;
    }

    // 防止克隆
    private function __clone()
    {
    }

    // 防止反序列化
    public function __wakeup()
    {
        if (self::$instance !== null) {
            throw new RuntimeException('反序列化不被允许');
        }

        self::$instance = $this;
    }
}
```

## 7. 实际应用场景

假设我们在一个系统中需要一个全局的日志管理类，可以使用单例模式来实现。以下是一个简化版的Java实现代码：

```java
public class Logger {
    private static Logger instance;
    
    private Logger() {
        // 私有构造函数，防止外部实例化
    }

    public static synchronized Logger getInstance() {
        if (instance == null) {
            instance = new Logger();
        }
        return instance;
    }

    public void log(String message) {
        System.out.println("Log message: " + message);
    }
}
```

在这个实现中，`Logger`类的构造函数是私有的，防止外部类直接创建实例。`getInstance()`方法提供了全局访问点，并且通过`synchronized`关键字确保在多线程环境下的线程安全性。每次调用`getInstance()`方法时，都会返回相同的`Logger`实例。

## 8. 总结与建议

单例模式作为一种常见的设计模式，解决了类实例化过多的问题，提供了全局访问点，减少了资源浪费。然而，单例模式也并非适用于所有场景。在使用时，开发者需要权衡其优缺点，避免过度设计和引入不必要的复杂性。未来，随着软件架构向微服务、云计算等现代开发模式转型，单例模式在这些新兴领域中的应用仍然值得关注。