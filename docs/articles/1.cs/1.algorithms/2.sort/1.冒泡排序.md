---
outline: deep
title: 冒泡排序
url: 1
createtime: 2025-06-16 09:41:11
updatetime: 2025-08-02 22:06:28
---

# 冒泡排序

## 1. 引言
在众多排序算法中，冒泡排序（Bubble Sort）是一种非常基础且易于理解的算法。排序算法在计算机科学中占有举足轻重的地位，尤其在数据处理、搜索引擎、数据库管理系统等领域，排序操作是不可或缺的。排序不仅能帮助我们快速地组织和处理数据，还能提高后续操作的效率。虽然冒泡排序因其效率较低而在大规模数据处理上受到限制，但由于其简单的实现逻辑和易于理解的特性，仍然在学习和教学中被广泛使用。

## 2. 起源与发展
冒泡排序的概念最早可以追溯到1950年代，它是由计算机科学家发明的排序方法之一。由于其简单易懂，冒泡排序成为了许多计算机科学教材中的示范算法。尽管它的效率较低，但作为排序算法的入门，冒泡排序帮助无数计算机科学学习者理解了排序的基本原理。

随着计算机科学的发展，冒泡排序的出现为其他更高效的排序算法奠定了基础。虽然冒泡排序在实际应用中逐渐被快速排序、归并排序等算法所取代，但它在教学、理论研究以及处理小规模数据时，依然具有一定的实用价值。

## 3. 基本概念与定式
### 1. 定义
冒泡排序是一种简单的排序算法，其基本思想是通过重复遍历待排序的数列，每次比较相邻的元素，如果它们的顺序错误，就交换它们的位置。这样，每一轮遍历结束后，最大的元素就像气泡一样“浮”到数列的末端。

### 2. 核心操作：
- **交换**：如果当前元素大于后一个元素，则交换它们的位置。

- **遍历**：对待排序的数列进行多次遍历，每次遍历将当前未排序部分的最大元素放到正确的位置。

### 3. 实现

#### java实现
##### 1. 基础的冒泡排序
```java
for (int i = 0; i < elements.length - 1; i++) {
    for (int j = 0; j < elements.length - i - 1; j++) {
        if (compare(j, j + 1) > 0) {
            swap(j, j + 1);
        }
    }
}
```
- 执行流程：
  - 1. 外层循环控制比较的轮数，外层循环的次数为元素个数减1。
  - 2. 内层循环控制每轮比较的次数，内层循环的次数为元素个数减去当前轮数。
  - 3. 每轮比较中，如果当前元素比下一个元素大，则交换位置。
  - 4. 循环结束后，数组中的最大元素已经排到了elements.length - i - 1，下一轮比较的元素个数减1。
  
##### 2. 另一个基础的冒泡排序
```java
for (int end = elements.length - 1; end > 0; end--) {
    for (int begin = 1; begin <= end; begin++) {
        if (compare(begin, begin - 1) < 0) {
            swap(begin, begin - 1);
        }
    }
}
```
- 执行流程：
  - 1. 外层循环控制每一轮的最后一个元素的位置，从元素个数减1开始，到1结束。
  - 2. 内层循环控制每一轮的比较次数，从1开始，到end结束。
  - 3. 每轮比较中，如果当前元素比前一个元素小，则交换位置。
  - 4. 内层循环结束后，数组中的最大元素已经排到了end位置，下一轮比较的元素个数减1

##### 3. 冒泡排序的优化：如果已经有序，则提前结束
```java
// 是否已经有序
boolean isSorted = true;
// 执行n - 1轮
for (int end = elements.length - 1; end > 0; end--) {
    // 每一轮执行都默认有序，发生交换后，有序变为false
    isSorted = true;
    for (int begin = 1; begin <= end; begin++) {
        if (compare(begin, begin - 1) < 0) {
            swap(begin, begin - 1);
            isSorted = false;
        }
    }
    // 如果已经有序，则提前结束
    if (isSorted) {
        break;
    }
}
```
- 执行流程
  - 1. 外层循环控制每一轮的最后一个元素的位置，从元素个数减1开始，到1结束。
  - 2. 内层循环控制每一轮的比较次数，从1开始，到end结束。
  - 3. 每轮比较中，如果当前元素比前一个元素小，则交换位置。
  - 4. 内层循环结束后，数组中的最大元素已经排到了end位置，下一轮比较的元素个数减1，
  如果已经有序了，那就直接退出外层循环

##### 4. 冒泡排序优化：确定最后一个有序的元素位置
```java
// 有序区的边界，每次循环都将无序区间的边界向左移动一位
int sortedIndex = 1;
// 执行n - 1轮循环
for (int end = elements.length - 1; end > 0; end--) {
    // 这里设置为1，在这轮循环中，如果没有发生一次交换，
    // 那end = sortedIndex，则下一轮循环时，end == 0，结束循环
    sortedIndex = 1;
    for (int begin = 1; begin <= end; begin++) {
        if (compare(begin, begin - 1) < 0) {
            swap(begin, begin - 1);
            sortedIndex = begin;
        }
    }
    // sortedIndex是最后一次有序的位置，
    // end = sortedIndex，下一轮循环时，
    // end = sortedIndex - 1
    end = sortedIndex;
}

```
- 执行流程
  - 1. 外层循环控制每一轮的最后一个元素的位置，从元素个数减1开始，到1结束。
  - 2. 内层循环控制每一轮的比较次数，从1开始，到end结束。
  - 3. 每轮比较中，如果当前元素比前一个元素小，则交换位置。
  - 4. 内层循环结束后，数组中的最大元素已经排到了end位置，更新end的值为最后一个有序的索引，下一轮比较的元素个数减1

具体实现代码在 [排序算法](https://gitee.com/shenlink/data-structures-and-algorithms-java/tree/master/src/main/java/com/hxqzzxk/sort) 中

#### php实现
##### 1. 基础的冒泡排序
```php
for ($i = 0; $i < count($this->elements) - 1; $i++) {
    // 每次遍历减少一个元素，因为最后一个元素已经到位
    for ($j = 0; $j < count($this->elements) - 1 - $i; $j++) {
        if ($this->compareByIndex($j, $j + 1) > 0) {
            $this->swap($j, $j + 1);
        }
    }
}
```
- 执行流程：
  - 1. 外层循环控制比较的轮数，外层循环的次数为元素个数减1。
  - 2. 内层循环控制每轮比较的次数，内层循环的次数为元素个数减去当前轮数。
  - 3. 每轮比较中，如果当前元素比前一个元素大，则交换位置。
  - 4. 循环结束后，数组中的最大元素已经排到了elements.length - i - 1，下一轮比较的元素个数减1。
  
##### 2. 另一个基础的冒泡排序
```php
for ($end = count($this->elements) - 1; $end > 0; $end--) {
    // 从 1 到 end 进行比较，如果前一个元素大于后一个元素，则交换位置
    for ($begin = 1; $begin <= $end; $begin++) {
        if ($this->compareByIndex($begin, $begin - 1) < 0) {
            $this->swap($begin, $begin - 1);
        }
    }
}

```
- 执行流程：
  - 1. 外层循环控制每一轮的最后一个元素的位置，从元素个数减1开始，到1结束。
  - 2. 内层循环控制每一轮的比较次数，从1开始，到end结束。
  - 3. 每轮比较中，如果当前元素比前一个元素小，则交换位置。
  - 4. 内层循环结束后，数组中的最大元素已经排到了end位置，下一轮比较的元素个数减1

##### 3. 冒泡排序的优化：如果已经有序，则提前结束
```php
// 是否已经有序
$isSorted = true;
// 执行 n - 1 轮
for ($end = count($this->elements) - 1; $end > 0; $end--) {
    // 每一轮执行都默认有序，发生交换后，有序变为 false
    $isSorted = true;
    for ($begin = 1; $begin <= $end; $begin++) {
        if ($this->compareByIndex($begin, $begin - 1) < 0) {
            $this->swap($begin, $begin - 1);
            $isSorted = false;
        }
    }
    // 如果已经有序，则提前结束
    if ($isSorted) {
        break;
    }
}
```
- 执行流程
  - 1. 外层循环控制每一轮的最后一个元素的位置，从元素个数减1开始，到1结束。
  - 2. 内层循环控制每一轮的比较次数，从1开始，到end结束。
  - 3. 每轮比较中，如果当前元素比前一个元素小，则交换位置。
  - 4. 内层循环结束后，数组中的最大元素已经排到了end位置，下一轮比较的元素个数减1，
  如果已经有序了，那就直接退出外层循环

##### 4. 冒泡排序优化：确定最后一个有序的元素位置
```php
// 有序区的边界，每次循环都将无序区间的边界向左移动一位
$sortedIndex = 1;
// 执行 n - 1 轮循环
for ($end = count($this->elements) - 1; $end > 0; $end--) {
    // 这里设置为1，在这轮循环中，如果没有发生一次交换，
    // 那 end = sortedIndex，则下一轮循环时，end == 0，结束循环
    $sortedIndex = 1;
    for ($begin = 1; $begin <= $end; $begin++) {
        if ($this->compareByIndex($begin, $begin - 1) < 0) {
            $this->swap($begin, $begin - 1);
            $sortedIndex = $begin;
        }
    }
    // sortedIndex是最后一次有序的位置，
    // end = sortedIndex，下一轮循环时，
    // end = sortedIndex - 1
    $end = $sortedIndex;
}
```
- 执行流程
  - 1. 外层循环控制每一轮的最后一个元素的位置，从元素个数减1开始，到1结束。
  - 2. 内层循环控制每一轮的比较次数，从1开始，到end结束。
  - 3. 每轮比较中，如果当前元素比前一个元素小，则交换位置。
  - 4. 内层循环结束后，数组中的最大元素已经排到了end位置，更新end的值为最后一个有序的索引，下一轮比较的元素个数减1

具体实现代码在 [排序算法](https://gitee.com/shenlink/data-structures-and-algorithms-php/tree/master/src/Sort) 中

## 4. 应用场景
- **常见应用**：冒泡排序适用于数据量较小、对性能要求不高的情况。它广泛用于教学中，以帮助学生理解排序算法的基本原理。它也可以在实时性要求较低的场景中使用，或者作为其他复杂算法的基础步骤。

- **实际案例**：尽管在工业界或科研中，冒泡排序很少用于处理大规模数据，但它依然在一些嵌入式系统中扮演着一定角色，尤其是在资源有限的小型设备中，冒泡排序因其实现简单、内存消耗较小而偶尔被使用。

## 5. 优缺点分析

### 优点
- **易于理解**：冒泡排序的实现原理简单，代码易于编写和理解，适合教学使用。

- **空间复杂度低**：它是原地排序算法，除了存储数据本身外，不需要额外的内存空间。

### 缺点
- **时间复杂度高**：冒泡排序的时间复杂度为O(n^2)，在数据量较大的情况下，效率低下。尤其在处理大规模数据时，冒泡排序的性能远不如其他更高效的排序算法（如快速排序、归并排序）。

## 6. 性能分析

### 1. 时间复杂度分析
冒泡排序的时间复杂度为O(n^2)，其中n是数组的长度。每次遍历的时间复杂度为O(n)，需要执行n-1轮遍历，因此总的时间复杂度为O(n^2)。在最坏的情况下，冒泡排序需要执行n-1轮比较和交换。

### 2. 空间复杂度分析
冒泡排序的空间复杂度为O(1)，因为它是原地排序算法，只需使用常数级别的额外空间来交换元素。

### 3. 实验数据
实验结果表明，冒泡排序在小规模数据集上的表现尚可，但在处理大规模数据时，其性能明显逊色于其他排序算法。例如，在n=1000的数组中，冒泡排序需要大约500,000次比较，而快速排序则仅需约10,000次比较。

## 7. 未来展望
随着计算机硬件的发展和算法的不断优化，冒泡排序可能会逐渐被更高效的排序算法所替代。然而，作为一种简单易懂的排序方法，它在教学领域仍将继续发挥作用。

冒泡排序作为一种基础算法，可能会与并行计算或分布式计算等新兴技术相结合，以提高其在大数据环境下的性能。

## 8. 总结
冒泡排序作为一种简单且易于理解的排序算法，尽管在大规模数据处理中效率低下，但它在教学中扮演着重要角色。它的优点在于实现简单和低空间复杂度，但其O(n^2)的时间复杂度在处理大量数据时表现不佳。

对于初学者来说，掌握冒泡排序有助于理解排序算法的基本概念，但在实际应用中，应尽量选择更高效的排序算法，如快速排序或归并排序，尤其是在处理大规模数据时。